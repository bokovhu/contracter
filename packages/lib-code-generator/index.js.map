{
  "version": 3,
  "sources": ["src/index.ts"],
  "sourcesContent": ["import { AppContract } from \"@degenhack/contract-model\";\r\n\r\n\r\nclass CodeGeneratorImpl {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    generateCode(\r\n        contract: AppContract\r\n    ): string {\r\n        const storageFields: Array<string> = [];\r\n        const messageMethods: Array<string> = [];\r\n\r\n        /*\r\n        #![cfg_attr(not(feature = \"std\"), no_std, no_main)]\r\n\r\n        #[ink::contract]\r\n        mod ctr {\r\n\r\n            #[ink(storage)]\r\n            pub struct Ctr {\r\n                value: bool,\r\n            }\r\n\r\n            impl Ctr {\r\n                #[ink(constructor)]\r\n                pub fn new() -> Self {\r\n                    Self { value: false }\r\n                }\r\n\r\n                #[ink(message)]\r\n                pub fn flip(&mut self) {\r\n                    self.value = !self.value;\r\n                }\r\n\r\n                #[ink(message)]\r\n                pub fn get(&self) -> bool {\r\n                    self.value\r\n                }\r\n            }\r\n        }\r\n        */\r\n\r\n        for(let para of contract.paragraphs) {\r\n\r\n            storageFields.push(\r\n                `paragraph_${para.index}_completed: bool`\r\n            );\r\n\r\n            let provIndex = 0;\r\n\r\n            for(let prov of para.provisions) {\r\n\r\n                if(prov.type === \"REQUIRE_DEPOSIT\") {\r\n                    storageFields.push(\r\n                        `storage_deposit_${para.index}_${provIndex}_deposited: bool`\r\n                    );\r\n                    messageMethods.push(\r\n                        `#[ink(message)]\\n` +\r\n                        `pub fn deposit_${para.index}_${provIndex}() -> Result<(), Error> {\\n` +\r\n                        // Check that caller is the depositor\r\n                        `    if(self.env().caller() != '${prov.payload.depositor}') { Err(Error::NotDepositor) }\\n` +\r\n                        // Check that env transferred_value is equal to amount\r\n                        `    if(self.env().transferred_value() != ${prov.payload.amount}) { Err(Error::IncorrectAmount) }\\n` +\r\n                        // Check that storage_deposit_${para.index}_${provIndex}_deposited is false\r\n                        `    if(self.storage_deposit_${para.index}_${provIndex}_deposited) { Err(Error::AlreadyDeposited) }\\n` +\r\n                        // Set storage_deposit_${para.index}_${provIndex}_deposited to true\r\n                        `    self.storage_deposit_${para.index}_${provIndex}_deposited = true;\\n` +\r\n                        `    Ok(())\\n` +\r\n                        `}\\n`\r\n                    );\r\n                } else if(prov.type === \"REQUIRE_SIGNATURE\") {\r\n                    storageFields.push(\r\n                        `storage_signature_${para.index}_${provIndex}_signed: bool`\r\n                    );\r\n                    messageMethods.push(\r\n                        `#[ink(message)]\\n` +\r\n                        `pub fn sign_${para.index}_${provIndex}() -> Result<(), Error> {\\n` +\r\n                        // Check that caller is the signer\r\n                        `    if(self.env().caller() != '${prov.payload.signer}') { Err(Error::NotSigner) }\\n` +\r\n                        // Check that storage_signature_${para.index}_${provIndex}_signed is false\r\n                        `    if(self.storage_signature_${para.index}_${provIndex}_signed) { Err(Error::AlreadySigned) }\\n` +\r\n                        // Set storage_signature_${para.index}_${provIndex}_signed to true\r\n                        `    self.storage_signature_${para.index}_${provIndex}_signed = true;\\n` +\r\n                        `    Ok(())\\n` +\r\n                        `}\\n`\r\n                    );\r\n                } else if(prov.type === \"CREATE_REWARD\") {\r\n                    storageFields.push(\r\n                        `storage_reward_${para.index}_${provIndex}_created: bool`\r\n                    );\r\n                    storageFields.push(\r\n                        `storage_reward_${para.index}_${provIndex}_claimed: bool`\r\n                    );\r\n                    messageMethods.push(\r\n                        `#[ink(message)]\\n` +\r\n                        `pub fn create_reward_${para.index}_${provIndex}() -> Result<(), Error> {\\n` +\r\n                        // Check that storage_reward_${para.index}_${provIndex}_created is false\r\n                        `    if(self.storage_reward_${para.index}_${provIndex}_created) { Err(Error::AlreadyCreated) }\\n` +\r\n                        // Set storage_reward_${para.index}_${provIndex}_created to true\r\n                        `    self.storage_reward_${para.index}_${provIndex}_created = true;\\n` +\r\n                        `    Ok(())\\n` +\r\n                        `}\\n`\r\n                    );\r\n                    messageMethods.push(\r\n                        `#[ink(message)]\\n` +\r\n                        `pub fn claim_reward_${para.index}_${provIndex}() -> Result<(), Error> {\\n` +\r\n                        // Check that storage_reward_${para.index}_${provIndex}_created is true\r\n                        `    if(!self.storage_reward_${para.index}_${provIndex}_created) { Err(Error::NotCreated) }\\n` +\r\n                        // Check that storage_reward_${para.index}_${provIndex}_claimed is false\r\n                        `    if(self.storage_reward_${para.index}_${provIndex}_claimed) { Err(Error::AlreadyClaimed) }\\n` +\r\n                        // Check that caller is the beneficiary\r\n                        `    if(self.env().caller() != '${prov.payload.beneficiary}') { Err(Error::NotBeneficiary) }\\n` +\r\n                        // Set storage_reward_${para.index}_${provIndex}_claimed to true\r\n                        `    self.storage_reward_${para.index}_${provIndex}_claimed = true;\\n` +\r\n                        // Transfer reward to beneficiary\r\n                        `    self.env().transfer('${prov.payload.beneficiary}', ${prov.reward});\\n` +\r\n                        `    Ok(())\\n` +\r\n                        `}\\n`\r\n                    );\r\n                }\r\n                \r\n                provIndex++;\r\n    \r\n            }\r\n\r\n        }\r\n\r\n        return `#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\r\n        #[ink::contract]\r\n        mod ctr {\r\n\r\n            #[ink(storage)]\r\n            pub struct Ctr {\r\n                ${storageFields.join(\",\\n\")}\r\n            }\r\n\r\n            impl Ctr {\r\n                #[ink(constructor)]\r\n                pub fn new() -> Self {\r\n                    Self {\r\n                        ${storageFields.map(f => f.split(\":\")[0]).map(f => `${f}: false`).join(\",\\n\")}\r\n                    }\r\n                }\r\n\r\n                ${messageMethods.join(\"\\n\")}\r\n\r\n            }\r\n        }`;\r\n\r\n    }\r\n\r\n}\r\n\r\nconst codeGeneratorInstance = new CodeGeneratorImpl();\r\n\r\nexport const generateCode = codeGeneratorInstance.generateCode.bind(codeGeneratorInstance);\r\n"],
  "mappings": "ybAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,kBAAAE,IAGA,IAAMC,EAAN,KAAwB,CAEpB,aAAc,CAEd,CAEA,aACIC,EACM,CACN,IAAMC,EAA+B,CAAC,EAChCC,EAAgC,CAAC,EAgCvC,QAAQC,KAAQH,EAAS,WAAY,CAEjCC,EAAc,KACV,aAAaE,EAAK,KAAK,kBAC3B,EAEA,IAAIC,EAAY,EAEhB,QAAQC,KAAQF,EAAK,WAEdE,EAAK,OAAS,mBACbJ,EAAc,KACV,mBAAmBE,EAAK,KAAK,IAAIC,CAAS,kBAC9C,EACAF,EAAe,KACX;AAAA,iBACkBC,EAAK,KAAK,IAAIC,CAAS;AAAA,iCAEPC,EAAK,QAAQ,SAAS;AAAA,2CAEZA,EAAK,QAAQ,MAAM;AAAA,8BAEhCF,EAAK,KAAK,IAAIC,CAAS;AAAA,2BAE1BD,EAAK,KAAK,IAAIC,CAAS;AAAA;AAAA;AAAA,CAGvD,GACMC,EAAK,OAAS,qBACpBJ,EAAc,KACV,qBAAqBE,EAAK,KAAK,IAAIC,CAAS,eAChD,EACAF,EAAe,KACX;AAAA,cACeC,EAAK,KAAK,IAAIC,CAAS;AAAA,iCAEJC,EAAK,QAAQ,MAAM;AAAA,gCAEpBF,EAAK,KAAK,IAAIC,CAAS;AAAA,6BAE1BD,EAAK,KAAK,IAAIC,CAAS;AAAA;AAAA;AAAA,CAGzD,GACMC,EAAK,OAAS,kBACpBJ,EAAc,KACV,kBAAkBE,EAAK,KAAK,IAAIC,CAAS,gBAC7C,EACAH,EAAc,KACV,kBAAkBE,EAAK,KAAK,IAAIC,CAAS,gBAC7C,EACAF,EAAe,KACX;AAAA,uBACwBC,EAAK,KAAK,IAAIC,CAAS;AAAA,6BAEjBD,EAAK,KAAK,IAAIC,CAAS;AAAA,0BAE1BD,EAAK,KAAK,IAAIC,CAAS;AAAA;AAAA;AAAA,CAGtD,EACAF,EAAe,KACX;AAAA,sBACuBC,EAAK,KAAK,IAAIC,CAAS;AAAA,8BAEfD,EAAK,KAAK,IAAIC,CAAS;AAAA,6BAExBD,EAAK,KAAK,IAAIC,CAAS;AAAA,iCAEnBC,EAAK,QAAQ,WAAW;AAAA,0BAE/BF,EAAK,KAAK,IAAIC,CAAS;AAAA,2BAEtBC,EAAK,QAAQ,WAAW,MAAMA,EAAK,MAAM;AAAA;AAAA;AAAA,CAGzE,GAGJD,GAIR,CAEA,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAMGH,EAAc,KAAK;AAAA,CAAK,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAOjBA,EAAc,IAAIK,GAAKA,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC,EAAE,IAAIA,GAAK,GAAGA,CAAC,SAAS,EAAE,KAAK;AAAA,CAAK,CAAC;AAAA;AAAA;AAAA;AAAA,kBAInFJ,EAAe,KAAK;AAAA,CAAI,CAAC;AAAA;AAAA;AAAA,UAKvC,CAEJ,EAEMK,EAAwB,IAAIR,EAErBD,EAAeS,EAAsB,aAAa,KAAKA,CAAqB",
  "names": ["src_exports", "__export", "generateCode", "CodeGeneratorImpl", "contract", "storageFields", "messageMethods", "para", "provIndex", "prov", "f", "codeGeneratorInstance"]
}
